/*
* A prototype grammar for a universal, all-purpose programming language called "Catholicus".
* Contents currently subject to change without notice, as this project is still in planning.
*
* Everything is a module.
*
* A module is a discrete, logical unit. A module may contain other modules of any kind and of any quantity.
*
*
* Universal Principles (regarding existence and creation, but not necessarily God Himself):
* 1. All things are unique.
* 2. All things have a single purpose.
* 3. All things have beginning and end[, or cause and purpose].
* 4. All creation is finite.
* 5. All things, in relation to God, are lesser origins like God according to His designs.
* 6. All order and power comes from God; no creature has power in itself.
* 7. All lesser origins are principles, composite or fundamental, and exhibit intelligent design, not chaos, as the cause.
* 8. All order exhibits hierarchical nature which I describe as the process of selective reduction and reification
* meaning that all things have an intentional and definite structure, and that they are capable of being converted from
* one form into another by reduction of composite principles to their foundation, and reification of fundamental principles
* to create unique, composite principles.
* 9. All principles inherit the qualities of their parent principles.
* 10. Non-contradiction: something cannot be and not be simultaneously.
* 11. Law of Continuity: A unique principle from one archetype principle cannot have the qualities of another archetype
* principle. [truth comes from truth; error comes from error; error cannot come from truth and vice versa.]
* 12. The Catholic Church is the One True Church of which all are obliged to be part of by a free act of their volition,
* outside of which there is no salvation[; Vatican II is a robber synod, and a grave departure from the truth because it
* preaches a "gospel" of religious liberty, ecumenism, and other heresies condemned by previous councils, Popes, etc.;
* the See is overrun by Freemasons, and the great apostasy has reached the Chair of Peter since the death of
* Pope Pius XII as prophesied by Bl. Anne Catherine Emmerich, and as declared in the true Third Secret of Fatima (which
* has been obscured and overwritten unlawfully)].
*
* Principles:
* A module:
* - is discrete
* - is a logical unit
* - may be logical
* - may be stateful
* - may not be both logical and stateful
* - may contain other modules of any kind
* - may contain other modules of any quantity
* - inherits via prototypical instantiation
* - is compatible with, but is not purely, the Actor Model
* - is compatible with, but is not intended to be, Object-Oriented in any of its many subjective definitions.
* - is compatible with, but is not purely, a functional programming language
* - is intended to be used for modular programming with the following guidelines, and subject to the universal
* principles listed above:
*     1. A module is created for a single purpose.
*     2. A module is unique (i.e. no redundancy or code duplication). This means that it is better to create a module
*       for even two very common statements or pieces of data than it is to either copy and paste those two lines if
*       they are used in more than one module. The language has built-in support for inline modules to ease this process
*       and make your code more readable.
*     3. A module is named after its objective intent (purpose), not subjective intent. For example, instead of creating
*       a logical module called "get_employee" with the subjective intent of getting an employee object from a database,
*       a name which reveals objective intent is "get_node". Do not name for why, but for what, and never about the how.
*     4. A module's implementation is visible only within the context of the module. The inputs and outputs of a module
*       must be explicitly defined by the module, and a module must have at least one input and one output. For logical
*       modules, this is more straightforward as they are functions. For stateful modules, the input is the initial
*       value of the module, and the output is the value returned when a member of the stateful module is read. For
*       modules without parameters, the inputs and outputs are implicitly defined by whatever is defined in the module.
*     5. Variables are modules.
*     6. It's documentation, not comments. Document your code vigorously, but do not be verbose. The
*       documentation is part of the code, and the code a part of the documentation.
*     7. Assume all code is verbatim: what you see is what you get. There are no true high-level abstractions in this
*       language. What abstractions that are present are for reducing boilerplate and improving readability while
*       reducing noise and increasing productivity of the programmer, and the performance of the application which is
*       contingent on how well you understand the abstract computational system that Catholicus runs on, and how well
*       your code conforms to this system.
*/

module :=
{
    // this is the general principle and format for all modules
    module-example_with_parameters (in0, in1) : (out0, out1) :=
    {
        statement0
        statement1
        statement2
    }

    // An expositional-interface
    expositional-interface (module-example_with_parameters) : (out0, out1) :=
    {
        out0 = statement2
        out1 = statement0
    }

    module-no_parameters :=
    {
        statement
        // ...
        variable-definition
        // ...
        statement
        // ...
    }

    traditional_function (in0, in1) : out0 :=
    {
        statement0
        statement1
        // ...
        out0 = expression
    }

    function_multi-out (in0, in1) : (out0, out1) :=
    {
        statement
        statement
        // ...
        out0 = expression
        out1 = expression
    }

    // demonstration of a concept of "pipelines"
    pipeline_common (a, b, c) : (x, y, z) :=
    {
        x = pipe0(a)
        y = pipe1(b)
        z = pipe2(c)
    }

    pipeline_extended (pipeline_common, a, b, c, d, e, f) : (x0, y0, z0, x1, y1, z1) :=
    {
        (x0, y0, z0) = pipeline_common(a, b, c)
        (x1, y1, z1) = pipeline_common(d, e, f)
    }

    pipe0 (a) :=
    {
        // ...
    }

    pipe1 (b) :=
    {
        // ...
    }

    pipe2 (c) :=
    {
        // ...
    }

}